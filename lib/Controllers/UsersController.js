/**
 * PlatformPublicAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class UsersController {
    /**
     * Get users with pagination
     * #### Additionally Data
     * ``` courses ```: Courses analytics (Progress, number of lessons, lessons which user
     * started)
     * ``` lifeTimeValue ```: The sum of all orders invoices
     * #### Response Data
     * ```json
     * {
     * "items": [
     * {
     * "_id": Id of User
     * "firstName": First Name
     * "lastName": Last Name
     * "createdAt": Registration Date
     * "email": Email
     * "courses": [
     * {
     * "_id": Id of course
     * "name": Name of course
     * "progress": Percentage progress
     * "startAt": Date, when user started course
     * "userLessonsStarted": Lessons, that user started
     * "lessonsCount": Total lessons in the course
     * }
     * ]
     * "lifeTimeValue": The sum of all orders invoices
     * }
     * ]
     * "pagination": {
     * "totalItems": Total items for all pages
     * "totalPages": Total pages
     * "page": Page number (Starts with 0)
     * "limit": Items for one page
     * "skip": -
     * }
     * }
     * ```
     *
     * @param {int} page TODO: type description here
     * @param {int} limit TODO: type description here
     * @param {string} name TODO: type description here
     * @param {string} email TODO: type description here
     * @param {string} additionallyData TODO: type description here
     * @param {string} xApiKey Secret API KEY
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getUsers(page, limit, name, email, additionallyData, xApiKey, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/users';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            page,
            limit,
            name,
            email,
            additionally_data: additionallyData,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'x-api-key': xApiKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'M200GetUsers');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Get user by ID
     * #### Additionally Data
     * ``` courses ```: Courses analytics (Progress, number of lessons, lessons which user
     * started)
     * ``` modules ```: Modules Analytics for Courses Analytics (Requires to pull courses in
     * Additionally Data)
     * ``` lessons ```: Lessons Analytics for Modules Analytics (Requires to pull courses and
     * modules in Additionally Data)
     * ``` orders ```: The sum of all orders invoices , total numbers of all invoices and all
     * orders data
     * ``` quizes ```: Results of finished quizes
     * ``` subscriptions ```: Active and Ended subscriptions
     * ##### In first item of modulesAnalytics array are lessons which has NO MODULE and their
     * progress
     * #### Response Data
     * ```json
     * {
     * "_id": ID of user
     * "firstName": First Name
     * "lastName": Last Name
     * "createdAt": Registration date
     * "email": Email
     * "credits": Total amount of credits
     * "finishedLessons": [
     * {
     * "_id": ID of lesson
     * "name": Lesson name
     * }
     * ]
     * "inProgressLessons": [
     * {
     * "_id": ID of lesson
     * "name": Lesson name
     * }
     * ]
     * "purchasedCourses": [
     * {
     * "_id": ID of course
     * "name": Course name
     * }
     * ]
     * "purchasedLessons": [
     * {
     * "_id": ID of lesson
     * "name": Lesson name
     * }
     * ]
     * "loginSessions": Total login sessions
     * "totalLoginTime": Total active time
     * "averageLoginTime": Average active time
     * "courses": [
     * {
     * "_id": Id of course
     * "name": Name of course
     * "progress": Percentage progress
     * "startAt": Date, when user started course
     * "userLessonsStarted": Lessons, that user started
     * "lessonsCount": Total lessons in the course
     * "modulesAnalytics": [
     * {
     * "progress": Progress of lessons with NO MODULE
     * "lessonsAnalytics": [
     * {
     * "_id": ID of lesson
     * "name": Lesson name
     * "notStartedYet": Flag, if user started this lesson (Boolean)
     * "isInProgress": Flag, if user has lesson in progress
     * (Boolean)
     * "isFinished": Flag, if user finished this lesson (Boolean)
     * }
     * ]
     * }
     * {
     * "_id": ID of module
     * "name": Module Name
     * "progress": Progress of module
     * "lessonsAnalytics": [
     * {
     * "_id": ID of lesson
     * "name": Lesson name
     * "notStartedYet": Flag, if user started this lesson (Boolean)
     * "isInProgress": Flag, if user has lesson in progress
     * (Boolean)
     * "isFinished": Flag, if user finished this lesson (Boolean)
     * }
     * ]
     * }
     * ]
     * }
     * ]
     * "totalPurchases": Total amount of all orders (Initial + recurring)
     * "lifeTimeValue": Total amount of spend money on platform
     * "orders": [
     * {
     * "_id": Id of order
     * "vs": Variable Symbol
     * "price": Price
     * "createdAt": Date of payment
     * "course": {
     * "_id": Id of course paid
     * "name": Name of course paid
     * }
     * }
     * {
     * "_id": Id of order
     * "vs": Variable Symbol
     * "price": Price
     * "createdAt": Date of payment
     * "checkout": {
     * "_id": Id of checkout paid
     * "name": Name of checkout paid
     * }
     * }
     * ]
     * "quizes": [
     * {
     * "_id": Id of quiz
     * "title": Quiz Title
     * "finishedAt": Date of quiz finish
     * "points": Points acquired in quiz
     * "results": [
     * {
     * "question": Question Text (String)
     * "answer": Answer (String)
     * }
     * ]
     * "reward": {
     * "title": Title of reward
     * "minPoints": Minimum points for reward
     * "maxPoints": Maximum points for reward
     * "creditsReward": Credits rewarded to user
     * "courses": [
     * {
     * "_id": Id of course rewarded to user
     * "name": Name of course rewarded to user
     * }
     * ]
     * }
     * }
     * ]
     * "subscriptions": [
     * {
     * "membershipStarted": Date of membership start
     * "membershipTo": Date of membership end (Or date of next payment)
     * "active": Flag, if subscriptions is still active (Boolean)
     * "refunded": Flag, if subscriptions is refunded (Boolean)
     * "isPastDue": Flag, if subscriptions is Past Due (Boolean)
     * "cancelled": Flag, if subscriptions is cancelled (Boolean)
     * "membership": {
     * "name": Name of subscription membership
     * }
     * "period": {
     * "name": Name of subscription membership period
     * }
     * }
     * ]
     * "endedSubscriptions": [
     * {
     * "membershipStarted": Date of membership start
     * "membershipTo": Date of membership ended
     * "active": false
     * "refunded": Flag, if subscriptions is refunded (Boolean)
     * "isPastDue": Flag, if subscriptions is Past Due (Boolean)
     * "cancelled": Flag, if subscriptions is cancelled (Boolean)
     * "membership": {
     * "name": Name of subscription membership
     * }
     * "period": {
     * "name": Name of subscription membership period
     * }
     * }
     * ]
     * }
     * ```
     *
     * @param {string} additionallyData Additionally data for pull, separated by comma
     * @param {string} userId TODO: type description here
     * @param {string} xApiKey Secret API KEY
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getUser(additionallyData, userId, xApiKey, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/users/{userId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            userId: { value: userId, encode: true },
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            additionally_data: additionallyData,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'x-api-key': xApiKey,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'M200GetUser');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 403) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(JSON.parse(_context.response.body), 'M403UserNotFoundException');
                    mappedObject.reason = 'Forbidden';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Forbidden', errorCode: 403, errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * #### Request Body (JSON)
     * ```json
     * {
     * "firstName": First Name *Required
     * "lastName": Last Name *Required
     * "email": Email *Required
     * "password": Password (If null, password will be generated and sent to user's email)
     * "role": Role ID (Default is USER ROLE)
     * "credits": Total amount of credits
     * "invoicing": {
     * "name": Company Name
     * "vatNo": VAT Number
     * "street": Invoicing Street
     * "city": Invoicing City
     * "countryCode": Incoicing Country Code
     * "zipcode": Invoicing Zip Code
     * }
     * }
     * ```
     *
     * @param {string} xApiKey Secret API KEY
     * @param {string} contentType TODO: type description here
     * @param {CreateUserRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createUser(xApiKey, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/users';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'x-api-key': xApiKey,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'M200CreateUser');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 403) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(JSON.parse(_context.response.body), 'M403ValidationErrorException');
                    mappedObject.reason = 'Forbidden';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Forbidden', errorCode: 403, errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * - Add course or courses to user purchases.
     * - User will get Lifetime access to this course/s
     * - Response is Array of users purchased courses
     * #### Request Body (JSON)
     * ```json
     * {
     * "courses": [String/Array] Course ID or Courses IDs Array *Required
     * }
     * ```
     *
     * @param {string} userId TODO: type description here
     * @param {string} xApiKey Secret API KEY
     * @param {string} contentType TODO: type description here
     * @param {AssignCoursesToUserRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static assignCoursesToUser(userId, xApiKey, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/users/{userId}/add-courses';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            userId: { value: userId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'x-api-key': xApiKey,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = parsed.map(model =>
                        _baseController.getObjectMapper().mapObject(model, 'M200AssignCourseToUser'));
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 500) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(JSON.parse(_context.response.body), 'M500NonValidCourseIDException');
                    mappedObject.reason = 'Internal Server Error';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Internal Server Error',
                        errorCode: 500,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * #### Request Body (JSON)
     * ```json
     * {
     * "firstName": First Name
     * "lastName": Last Name
     * "email": Email
     * "password": Password (If null, password will be generated and sent to user's email)
     * "role": Role ID (Default is USER ROLE)
     * "credits": Total amount of credits
     * "invoicing": {
     * "name": Company Name
     * "vatNo": VAT Number
     * "street": Invoicing Street
     * "city": Invoicing City
     * "countryCode": Incoicing Country Code
     * "zipcode": Invoicing Zip Code
     * }
     * }
     * ```
     *
     * @param {string} userId TODO: type description here
     * @param {string} xApiKey Secret API KEY
     * @param {string} contentType TODO: type description here
     * @param {UpdateUserRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateUser(userId, xApiKey, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/users/{userId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            userId: { value: userId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'x-api-key': xApiKey,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'M200UpdateUser');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 403) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(JSON.parse(_context.response.body), 'M403ValidationError2Exception');
                    mappedObject.reason = 'Forbidden';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Forbidden', errorCode: 403, errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * It's impossible to delete user with orders. If you want delete user with orders, contact
     * support
     * ---
     * Deleting user also delete user's
     * - Comments
     * - Threads
     * - Lessons and bonuses notes
     * - Subscriptions
     * - Quiz
     * - Course Analytics
     *
     * @param {string} userId TODO: type description here
     * @param {string} xApiKey Secret API KEY
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteUser(userId, xApiKey, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/users/{userId}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            userId: { value: userId, encode: true },
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'x-api-key': xApiKey,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'M200DeleteUser');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 403) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(JSON.parse(_context.response.body), 'M403UserNotFoundException');
                    mappedObject.reason = 'Forbidden';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Forbidden', errorCode: 403, errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
}
module.exports = UsersController;
